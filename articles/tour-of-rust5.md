---
title: "Tour of Rust 第5章(データの所有権と借用)まとめ"
emoji: "🐥"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["rust"]
published: false
---

ここでのまとめ

```
所有権
スコープベースのリソース管理
ドロップは階層的
所有権の移動
所有権を返す
参照による所有権の借用
参照による所有権の可変な借用
参照外し
借用したデータの受け渡し
参照の参照
明示的なライフタイム
複数のライフタイム
スタティックライフタイム
データ型のライフタイム

```

## 所有権

・型のインスタンスを作成して変数に束縛するとメモリリソースが作成される
・その全てのライフタイムに渡って Rust コンパイラが検証
・束縛された変数はリソースの所有者と呼ばれる

```
struct Foo {
  x: i32,
}
fn main() {
  // 構造体をインスタンス化し、変数に束縛してメモリリソース作成
  let foo = Foo { x: 42 };
  // foo = リソースの所有者
}
```

### スコープベースのリソース管理

・Rust では、スコープの終わりをリソースのデストラクトと開放の場所として使用する
・このデストラクトと解放のことを drop と呼ぶ。
・Rust には GC(ガベージコレクション)がない

```
struct Foo {
  x: i32,
}
fn main() {
  let foo_a = Foo { x: 42 };
  let foo_b = Foo { x: 13};
  println!("{}", foo_a.x);
  println!("{}", foo_b.x);
  // foo_b はここでドロップ
  // foo_a はここでドロップ
}
=> 42
```

### ドロップは階層的

・構造体がドロップされると、まず構造体自体がドロップされ、次にその子要素が個別に削除される
・メモリを自動的に解放することで、メモリリークを軽減できる
・メモリリソースのドロップは一度しかできない

```
struct Bar {
  x: i32,
}
struct Foo {
  bar: Bar,
}
fn main() {
  let foo = Foo { bar: Bar { x; 42 } };
  println!("{}", foo.bar.x);
  // foo が最初にドロップ
  // 次に foo.bar がドロップ
}
=> 42
```

## 所有権の移動

・所有者が関数の実引数として渡されると、所有権は関数の仮引数に移動する
・移動後、元の関数内の変数は使用できない
・移動している間、所有者の値のスタックメモリは、関数呼び出しパラメータのスタックメモリにコピーされる
・実引数として渡される →
移動中は、スタックメモリは関数呼び出しがわのパラメータのスタックメモリに一旦コピー →
・移動し終わったら、元の関数内の変数は使用できない（所有権の移動）

```
struct Foo {
  x: i32,
}

fn do_something(f: Foo) {
  println!("{}", f.x);
  // f はここでドロップ
}

fn main() {
  let foo = Foo { x: 42 };
  // foo の所有権は　do_something に移動
  do_something(foo);
  // foo は使えなくなる
}
```

### 所有権を返す

・所有権を関数から返すこともできる

```
struct Foo {
  x: i32,
}
fn do_something() -> Foo {
  Foo { x: 42 }
  // 所有権は外に移動
}
fn main() {
  let foo = do_something();
  // foo は所有者になる
  // 関数はスコープの終端により、foo はドロップ
}
```

## 参照による所有権の借用

・参照は & 演算子を使ってリソースへのアクセスを借用できる
・参照も他のリソース同様にドロップされる

```
struct Foo {
  x: i32,
}
fn main() {
  let foo = Foo { x: 42 };
  let f = &foo;
  println!("{}", f.x);
  // f はここでドロップ
  // foo はここでドロップ
}
```

## 参照による所有権の可変な借用

・&mut 演算子を使えば、リソースへの変更可能なアクセスを借用できる
・リソースの所有者は、可変な借用の間は移動や変更ができない
・データ競合を防止するため、Rust では同時に２つの変数から値を変更できない

```
struct Foo = {
  x: i32,
}
fn do_something(f: foo) {
  // mut がついているため、ミュータブルである
  let mut foo = Foo { x: 42 };

  // &mut はそんな mut に対して借用ができる
  let f = &mut foo;
  // 失敗: do_something(foo) はここでエラー
  // foo は可変に借用されている

  // 失敗: foo.x = 13;はここでエラー
  // foo は可変に借用されている間は変更できない
  f.x = 13;

  // f はここから先では使用されなければドロップされる
  println!("{}", foo.x);

  // 可変な借用はドロップされているため借用可能
  foo.x = 7;

  // foo の所有権を関数に移動
  do_something(foo);
}
```

## 参照外し

・&mut による参照では、* 演算子によって参照をはずす(dereference)ことで、所有権者の値を設定できる
・*演算子によって所有者のあたいのコピーを取得することができる（コピー可能な型については、後述）

```
fn main() {
  let mut foo = 42;
  let f = &mut foo;
  ler bar = *f; //所有者の値を取得
  *f = 13; //参照の所有者の値を設定
  println!("{}", bar);
  println!("{}", foo);
}
=> 42 13
```

## 借用したデータの受け渡し

・Rust では、可変な参照が１つだけか、不変な参照が複数化のどちらかが許可される
・両方は

・複数の型を組み合わせて新しい型を作ることができる（Rust が algebraic types(代数型) を持つと言われ理由）

```

```

## 参照の参照

・enum は一個もしくは複数な型のデータを持つことができ、C 言語の union のような表現ができる

・複数の型を組み合わせて新しい型を作ることができる（Rust が algebraic types(代数型) を持つと言われ理由）

```

```

## 明示的なライフタイム

・enum は一個もしくは複数な型のデータを持つことができ、C 言語の union のような表現ができる

・複数の型を組み合わせて新しい型を作ることができる（Rust が algebraic types(代数型) を持つと言われ理由）

```

```

## 複数のライフタイム

・enum は一個もしくは複数な型のデータを持つことができ、C 言語の union のような表現ができる

・複数の型を組み合わせて新しい型を作ることができる（Rust が algebraic types(代数型) を持つと言われ理由）

```

```

## スタティックライフタイム

・enum は一個もしくは複数な型のデータを持つことができ、C 言語の union のような表現ができる

・複数の型を組み合わせて新しい型を作ることができる（Rust が algebraic types(代数型) を持つと言われ理由）

```

```

## データ型のライフタイム

・enum は一個もしくは複数な型のデータを持つことができ、C 言語の union のような表現ができる

・複数の型を組み合わせて新しい型を作ることができる（Rust が algebraic types(代数型) を持つと言われ理由）

```

```
