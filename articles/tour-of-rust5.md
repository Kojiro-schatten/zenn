---
title: "Tour of Rust 第5章(データの所有権と借用)まとめ"
emoji: "🐥"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["rust"]
published: true
---

ここでのまとめ

```
所有権
スコープベースのリソース管理
ドロップは階層的
所有権の移動
所有権を返す
参照による所有権の借用
参照による所有権の可変な借用
参照外し
借用したデータの受け渡し
参照の参照
明示的なライフタイム
複数のライフタイム
スタティックライフタイム
データ型のライフタイム

```

## 所有権

・型のインスタンスを作成して変数に束縛するとメモリリソースが作成される
・その全てのライフタイムに渡って Rust コンパイラが検証
・束縛された変数はリソースの所有者と呼ばれる

```
struct Foo {
  x: i32,
}
fn main() {
  // 構造体をインスタンス化し、変数に束縛してメモリリソース作成
  let foo = Foo { x: 42 };
  // foo = リソースの所有者
}
```

## スコープベースのリソース管理

・Rust では、スコープの終わりをリソースのデストラクトと開放の場所として使用する
・このデストラクトと解放のことを drop と呼ぶ。
・Rust には GC(ガベージコレクション)がない

```
struct Foo {
  x: i32,
}
fn main() {
  let foo_a = Foo { x: 42 };
  let foo_b = Foo { x: 13};
  println!("{}", foo_a.x);
  println!("{}", foo_b.x);
  // foo_b はここでドロップ
  // foo_a はここでドロップ
}
=> 42
```

## ドロップは階層的

・構造体がドロップされると、まず構造体自体がドロップされ、次にその子要素が個別に削除される
・メモリを自動的に解放することで、メモリリークを軽減できる
・メモリリソースのドロップは一度しかできない

```
struct Bar {
  x: i32,
}
struct Foo {
  bar: Bar,
}
fn main() {
  let foo = Foo { bar: Bar { x; 42 } };
  println!("{}", foo.bar.x);
  // foo が最初にドロップ
  // 次に foo.bar がドロップ
}
=> 42
```

## 所有権の移動

・所有者が関数の実引数として渡されると、所有権は関数の仮引数に移動する
・移動後、元の関数内の変数は使用できない
・移動している間、所有者の値のスタックメモリは、関数呼び出しパラメータのスタックメモリにコピーされる
・実引数として渡される →
移動中は、スタックメモリは関数呼び出しがわのパラメータのスタックメモリに一旦コピー →
・移動し終わったら、元の関数内の変数は使用できない（所有権の移動）

```
struct Foo {
  x: i32,
}

fn do_something(f: Foo) {
  println!("{}", f.x);
  // f はここでドロップ
}

fn main() {
  let foo = Foo { x: 42 };
  // foo の所有権は　do_something に移動
  do_something(foo);
  // foo は使えなくなる
}
```

## 所有権を返す

・所有権を関数から返すこともできる

```
struct Foo {
  x: i32,
}
fn do_something() -> Foo {
  Foo { x: 42 }
  // 所有権は外に移動
}
fn main() {
  let foo = do_something();
  // foo は所有者になる
  // 関数はスコープの終端により、foo はドロップ
}
```

## 参照による所有権の借用

・参照は & 演算子を使ってリソースへのアクセスを借用できる
・参照も他のリソース同様にドロップされる

```
struct Foo {
  x: i32,
}
fn main() {
  let foo = Foo { x: 42 };
  let f = &foo;
  println!("{}", f.x);
  // f はここでドロップ
  // foo はここでドロップ
}
```

## 参照による所有権の可変な借用

・&mut 演算子を使えば、リソースへの変更可能なアクセスを借用できる
・リソースの所有者は、可変な借用の間は移動や変更ができない
・データ競合を防止するため、Rust では同時に２つの変数から値を変更できない

```
struct Foo = {
  x: i32,
}
fn do_something(f: foo) {
  // mut がついているため、ミュータブルである
  let mut foo = Foo { x: 42 };

  // &mut はそんな mut に対して借用ができる
  let f = &mut foo;
  // 失敗: do_something(foo) はここでエラー
  // foo は可変に借用されている

  // 失敗: foo.x = 13;はここでエラー
  // foo は可変に借用されている間は変更できない
  f.x = 13;

  // f はここから先では使用されなければドロップされる
  println!("{}", foo.x);

  // 可変な借用はドロップされているため借用可能
  foo.x = 7;

  // foo の所有権を関数に移動
  do_something(foo);
}
```

## 参照外し

・&mut による参照では、* 演算子によって参照をはずす(dereference)ことで、所有権者の値を設定できる
・*演算子によって所有者のあたいのコピーを取得することができる（コピー可能な型については、後述）

```
fn main() {
  let mut foo = 42;
  let f = &mut foo;
  ler bar = *f; //所有者の値を取得
  *f = 13; //参照の所有者の値を設定
  println!("{}", bar);
  println!("{}", foo);
}
=> 42 13
```

## 借用したデータの受け渡し

・Rust では、可変な参照が１つだけか、不変な参照が複数化のどちらかが許可される
・両方は同時に使用できない
・参照は所有者よりも長く存在してはいけない
・参照の最初のルールはデータ競合を防ぐ
・データを読み込む際、データへの書き込みが同時に行われると、同期が取れなくなる可能性がある
・マルチスレッドプログラミングでよく起こる
・参照の 2 番目のルールは、存在しないデータへの書き込みが同時に行われる
・参照の 2 番目のルールは、存在しないデータへの参照による誤作動を防ぐ

```
struct Foo {
  x: i32,
}
fn do_something(f: &mut Foo) {
  f.x += 1;
  // fへの可変な参照はここでドロップ
}
fn main() {
  let mut foo = Foo { x: 42 };
  do_something(&mut foo);
  // 関数do_somethingで可変な参照はドロップされる
  // 別の参照を作ることが可能
  do_something(&mut foo);
  // foo はここでドロップ
}

```

## 参照の参照

・参照の一部を参照することができる

```
struct Foo {
  x: i32,
}
fn do_something(a: &Foo) -> &i32 {
  return &a.x;
}
fn main() {
  let mut foo = Foo { x: 42 };
  let x = &mut foo.x;
  *x = 13;
  // x はここでドロップされるため、不変な参照が作成可能
  let y = do_something(&foo);
  println!("{}", y);
  // y はここでドロップ
  // foo はここでドロップ
}
=> 13
```

## 明示的なライフタイム

・（コードに現れるわけではないが）コンパイラは全ての変数のライフタイムを管理している
・参照がその所有者よりも長く存在しないことを検証する
・関数は、どの引数と戻り値とがライフタイムを共有しているか、識別のための指定子で指定できる
・ライフタイム指定子は ' で始まる('a, 'b)

```
struct Foo {
  x: i32,
}
fn do_something<'a>(foo: &'a Foo) -> &'a i32 {
  return &foo.x;
}
fn main() {
  let mut foo = Foo { x: 42 };
  let x = &mut foo.x;
  *x = 13;
  // xはここでドロップされるので、不変な参照が作られる
  let y = do_something(&foo);
  println!("{}", y);
  // y はここでドロップ
  // foo はここでドロップ
}
=> 13
```

## 複数のライフタイム

・ライフタイム指定子は関数の引数や戻り値のライフタイムをコンパイラが解決できない場合に、明示的に指定することができる

```
struct Foo {
  x: i32,
}
// foo_b と戻り値はライフタイムを共有
// foo_a のライフタイムは別
fn do_something<'a, 'b>(foo_a: &'a Foo, foo_b: &'b Foo) -> &'b i32 {
  println!("{}", foo_a.x);
  println!("{}", foo_b.x);
  return &foo_b.x;
}
fn main() {
  let foo_a = Foo { x: 42 };
  let foo_b = Foo { x: 12 };
  let x = do_something(&foo_a, &foo_b); // この時点で、do_somethingが呼ばれるので42,12が出力される
  // ここから先は foo_b のライフタイムしか存在しないため、foo_a はここでドロップ
  println!("{}", x);
  // x がドロップ
  // foo_b がドロップ
}
=> 42 12
12
```

## スタティックライフタイム

・スタティック変数は、コンパイル時に作成され、プログラムの開始から終了まで存在するメモリリソース
・これらの変数の型は明示的に指定する必要がある
・スタティックライフタイムとは「プログラムの終了まで無限に持続するメモリリソース」
・そのリソースは実行時にも作成できる
・その中に、特別なライフタイム指定子 'static がある
・'static は決してドロップすることがない（永続）
・スタティックライフタイムを持つリソースが「参照」を含む場合、全て' static でないといけない
・グローバルアクセスして読み取れる以上、スタティック変数を変更することが本質的に危険
・unsafe {...} を使用することで、コンパイラがメモリを保証できない操作を実行できる

```
// static PI を明示的に型を指定(f64)
static PI: f64 = 3.1415;

fn main() {
  // スタティック変数は関数内でも定義可能
  static mut SECRET: &'static str = "swordfish";
  // 文字列リテラルは 'static ライフタイム
  let msg: &'static str = "Hello World!";
  let p: &'static f64 = &PI;
  println!("{} {}", msg, p);
  // ルールを破る場合、明示する必要がある
  unsafe {
    SECRET = "abracadabra";
    println!("{}", SECRET);
  }
}
=> Hello World! 3.1415
abracadabra
```

## データ型のライフタイム

・関数同様、データ型はメンバのライフタイムを指定できる
・参照を含む構造体が、その参照が指す所有者よりも長く存在しないことを検証する
・構造体には何もないところを指している参照を含めることができない

```
struct Foo <'a> {
  i:&'a i32
}

fn main() {
  let x = 42;
  let foo = Foo {
    i: &x
  };
  println!("{}", foo.i);
}
```
